<!--Хедер (+скрипты)-->
<?
$PageTitle="Глава 2. Переменные PHP";
function customPageHeader(){?>
  <title>Глава 2. Переменные PHP</title>
<?}
include_once $_SERVER['DOCUMENT_ROOT']."/common/header.php";
?>



<h2>Переменные</h2>
<p>Символ <span class="code">$</span> используется в разных языках программирования в различных целях. Например, в языке BASIC символ <span class="code">$</span> применялся в качестве завершения имен переменных, чтобы показать, что они относятся к строкам</p>

<p>А в PHP символ <span class="code">$</span> должен ставиться перед именами всех переменных. Это нужно для того, чтобы PHP-парсер работал быстрее, сразу же понимая, что имеет дело с переменной. К какому бы типу ни относились переменные — к числам, строкам или массивам, все они должны выглядеть так, как показано</p>
<pre><code class="language-php">&lt;?php
 $mycounter = 1;
 $mystring = "Hello";
 $myarray = array("One", "Two", "Three");
?></code></pre>
<h3>Правила присваивания имен переменных</h3>
<ul>
    <li>Имена после знака <span class="code">$</span> должны начинаться с буквы или с _</li>
    <li>Имена могут содержать <span class="code">[a-zA-Z0-9_]</span></li>
    <li>Имена не могут включать пробелы</li>
    <li>Имена переменных чувствительны к регистру символов</li>
</ul>




<h3>Операторы присваивания</h3>
<p>Аналогичные другим языкам за исключением <span class="code">.=</span></p>

<h3>Типы переменных</h3>
<p>PHP автоматически преобразует типы.</p>
<p>Например, автоматическое преобразование числа в строку</p>
<pre><code class="language-php">&lt;?php
 $number = 12345 * 67890;
 echo substr($number, 3, 1);
?></code></pre>
<p>Когда присваивается значение, $number является числовой переменной. Но во
    второй строке кода вызов значения этой переменной помещен в PHP-функцию
    substr(), которая должна вернуть из переменной $number один символ, стоящий
    на четвертой позиции.  Для выполнения этой задачи PHP превращает $number в строку, состоящую из девяти символов, чтобы функция substr() могла получить к ней
    доступ и вернуть символ, в данном случае 1</p>
<p>Автоматическое преобразование строки в число:</p>
<pre><code class="language-php">&lt;?php
 $pi = "3.1415927";
 $radius = 5;
 echo $pi * ($radius * $radius);
?></code></pre>
<h4>Константы</h4>
<p>Константы, как и переменные, хранят информацию для последующего доступа,
    за исключением того, что они оправдывают свое название (постоянные). Иными
    словами, после определения констант их значения устанавливаются для всей
    остальной программы и не могут быть изменены. </p>
<p>К примеру, константа может использоваться для хранения местоположения
    корневого каталога вашего сервера (папки, содержащей основные файлы вашего
    сайта). Определить такую константу можно следующим образом:</p>
<pre><code class="language-php">define("ROOT_LOCATION", "/usr/local/www/");</code></pre>
Затем для чтения содержимого константы нужно просто сослаться на нее как
на обычную переменную (но не предваряя ее имя знаком доллара):
<pre><code class="language-php">$directory = ROOT_LOCATION;</code></pre>
<p>Теперь, как только понадобится запустить ваш PHP-код на другом сервере
    с другой конфигурацией папок, придется изменить только одну строку кода.</p>
<p>Важно помнить о двух основных особенностях констант: перед их именами
    не нужно ставить символ $ (в отличие от имен обычных переменных) и их
    можно определить только с помощью функции define().</p>
<p>По общепринятому соглашению считается правилом хорошего тона использовать в именах констант буквы только верхнего регистра, особенно если ваш код
    будет также читать кто-нибудь другой.</p>
<h4>Предопределенные константы</h4>
<p>существуют константы, известные как волшебные, которые могут оказаться для вас полезными с самого начала. У имен волшебных констант в начале
    и в конце всегда стоят два символа подчеркивания, чтобы нельзя было случайно
    назвать одну из собственных констант уже занятым под эти константы именем</p>
<table class="first_column_code">
    <tr>
        <td>Волшебная константа</td>
        <td>Описание</td>
    </tr>
    <tr>
        <td>__line__</td>
        <td>номер текущей строки вфайле</td>
    </tr>
    <tr>
        <td>__file__</td>
        <td>полное путевое имя файла. если используется внутри инструкции include,
            то возвращается имя включенного файла. внекоторых операционных системах
            допускается использование псевдонимов для каталогов, которые называются
            символическими ссылками; в__file__ они всегда заменяются реальными
            каталогами</td>
    </tr>
    <tr>
        <td>__dir__ </td>
        <td>каталог файла. если используется внутри инструкции include, то возвращается каталог включенного файла. такой же результат дает применение функции
            dirname(__file__). вэтом имени каталога отсутствует замыкающий слеш,
            если только этот каталог не является корневым</td>
    </tr>
    <tr>
        <td>__function__ </td>
        <td>имя функции. возвращает имя функции, под которым она была объявлена
            (сучетом регистра символов). вphp 4 возвращаемое значение всегда составлено из символов нижнего регистра </td>
    </tr>
    <tr>
        <td>__class__</td>
        <td>имя класса. возвращает имя класса, под которым он был объявлен (с учетом
            регистра символов). вphp4 возвращаемое значение всегда составлено изсимволов нижнего регистра</td>
    </tr>
    <tr>
        <td>__method__</td>
        <td>имя метода класса. возвращает имя метода, под которым он был объявлен
            (сучетом регистра символов)</td>
    </tr>
    <tr>
        <td>__namespace__</td>
        <td>имя текущего пространства имен (с учетом регистра символов). эта константа
            определена во время компиляции </td>
    </tr>
</table>
<p>Эти константы полезны при отладке, когда нужно вставить строку кода, чтобы
    понять, до какого места дошло выполнение программы:
</p>
<pre><code class="language-php">echo "Это строка " . _LINE_ . " в файле " . _FILE_;</code></pre>
<p>Эта команда выведет в браузер текущую строку программы с указанием текущего
    файла, исполняемого в данный момент (включая путь к нему).</p>

<h3>echo и print</h3>
<p>В общем, команда echo обычно работает при выводе обычного текста быстрее
    print, поскольку она не устанавливает возвращаемое значение. С другой стороны, поскольку она не является функцией, ее, в отличие от print, нельзя использовать как часть более сложного выражения. В следующем примере для
    вывода информации о том, является значение переменной истинным (TRUE) или
    ложным (FALSE), используется функция print, но сделать то же самое с помощью команды echo не представляется возможным, поскольку она выведет на экран
    сообщение об ошибке синтаксического разбора — Parse error:</p>
<pre><code class="language-php">$b ? print "TRUE" : print "FALSE";</code></pre>
<h3>Функции</h3>
<p>Простое объявление функции</p>
<pre><code class="language-php">&lt;?php
 function longdate($timestamp)
 {
 return date("l F jS Y", $timestamp);
 }
?></code></pre>
<p>Эта функция возвращает дату в формате «день_недели месяц число год». Между
    стоящими после имени функции круглыми скобками может размещаться любое количество параметров, но для этой функции выбран прием только одного
    параметра. Весь код, который выполняется при последующем вызове функции,
    заключается в фигурные скобки. Обратите внимание, что в этом примере первой буквой в вызове функции даты является L в нижнем регистре, которую не
    следует путать с цифрой 1.</p>
<p>Чтобы с помощью этой функции вывести сегодняшнюю дату, нужно поместить
    в свой код следующий вызов:</p>
<pre><code class="language-php">echo longdate(time());</code></pre>

<?
function longdate($timestamp)
{
    return date("l F jS Y", $timestamp);
}
?>
<p>Вывод: <?echo longdate(time());?></p>


<h4>Область видимости переменной</h4>
<p>Если программа очень длинная, то с подбором подходящих имен переменных могут возникнуть трудности, но программируя на PHP, можно определить область видимости переменной. Иными словами, можно, к примеру, указать, что переменная <span class="code">$temp</span> будет использоваться только внутри конкретной функции, чтобы забыть о том, что она после возврата из кода функции применяется где-нибудь еще. Фактически именно такой в PHP является по умолчанию область видимости переменных.</p>
<p>В качестве альтернативы можно проинформировать PHP о том, что переменная
    имеет глобальную область видимости и доступ к ней может быть осуществлен
    из любого места программы.</p>
<h5>Локальные переменные</h5>
<p>Локальные переменные создаются внутри функции и к ним имеется доступ
    только из кода этой функции. Обычно это временные переменные, которые
    используются до выхода из функции для хранения частично обработанных
    результатов.</p>
<pre><code class="language-php">&lt;?php
 function longdate($timestamp)
 {
 $temp = date("l F jS Y", $timestamp);
 return "Дата: $temp";
 }
?></code></pre>
<p>Неудачная попытка получить доступ к переменной $temp
    в функции longdate()</p>
<pre><code class="language-php">&lt;?php
 $temp = "Дата: ";
 echo longdate(time());
 function longdate($timestamp)
 {
 return $temp . date("l F jS Y", $timestamp);
 }
?></code></pre>
<p>Но поскольку переменная $temp не была создана внутри функции longdate,
    а также не была передана ей в качестве параметра, функция longdate не может
    получить к ней доступ. Поэтому этот фрагмент кода выведет только дату без
    предшествующего ей текста. На самом деле в зависимости от параметров конфигурации PHP сначала может быть отображено сообщение об ошибке, предупреждающее об использовании неопределенной переменной (Notice: Undefined
    variable: temp), показывать которое пользователям не хотелось бы.</p>
<p>. Решить проблему можно путем переноса ссылки на переменную
    $temp в ее локальную область видимости</p>
<pre><code class="language-php">&lt;?php
 $temp = "Дата: ";
 echo $temp . longdate(time());
 function longdate($timestamp)
 {
 return date("l F jS Y", $timestamp);
 }
?></code></pre>
<h5>Глобальные переменные</h5>
<p>Бывают случаи, когда требуется переменная, имеющая глобальную область видимости, поскольку нужно, чтобы к ней имелся доступ из всего кода программы. </p>
<pre><code class="language-php">global $is_logged_in;
</code></pre>
<h5>Статические переменные</h5>
<p>Если функция
    вызывается многократно, то она начинает свою работу со свежей копией переменной и ее прежние установки не имеют никакого значения.
    Интересно, а что, если внутри функции есть такая локальная переменная,
    к которой не должно быть доступа из других частей программы, но значение оторой желательно сохранять до следующего вызова функции? Зачем? Возможно, потому, что нужен некий счетчик, чтобы следить за количеством вызовов функции. Решение, показанное в примере 3.17, заключается в объявлении
    статической переменной.
</p>
<pre><code class="language-php">&lt;?php
 function test()
 {
 static $count = 0;
 echo $count;
 $count++;
 }
?></code></pre>
<p>В этом примере в самой первой строке функции создается статическая переменная по имени $count, которой присваивается нулевое начальное значение.
    В следующей строке выводится значение переменной, а в последней строке это
    значение увеличивается на единицу.</p>
<pre><code class="language-php">&lt;?php
 static $int = 0; // Допустимо
 static $int = 1+2; // Верно (в PHP 5.6)
 static $int = sqrt(144); // Недопустимо
?></code></pre>
<h5>Суперглобальные переменные</h5>
<p> Смысл этого названия заключается в том, что они предоставляются средой окружения PHP
    и имеют глобальную область видимости внутри программы, то есть доступны
    абсолютно из любого ее места. В этих суперглобальных переменных содержится масса полезной информации
    о текущей работающей программе и ее окружении</p>
<table class="first_column_code">
    <tr>
        <td>Имя суперглобальной
            переменной</td>
        <td>Ее содержимое</td>
    </tr>
    <tr>
        <td>$GLOBALS</td>
        <td>все переменные, которые на данный момент определены в глобальной области видимости сценария. Имена переменных служат ключами массива</td>
    </tr>
    <tr>
        <td>$_SERVER</td>
        <td>информация озаголовках, путях, местах расположения сценариев. элементы
            этого массива создаются веб-сервером, иэто не дает гарантии, что каждый
            веб-сервер будет предоставлять какую-то часть информации или ее всю</td>
    </tr>
    <tr>
        <td>$_GET</td>
        <td>переменные, которые передаются текущему сценарию http-методом get
        </td>
    </tr>
    <tr>
        <td>$_POST</td>
        <td>переменные, которые передаются текущему сценарию http-методом post
        </td>
    </tr>
    <tr>
        <td>$_FILES</td>
        <td>элементы, подгруженные ктекущему сценарию http-методом post</td>
    </tr>
    <tr>
        <td>$_COOKIE</td>
        <td>переменные, переданные текущему сценарию посредством http cookies</td>
    </tr>
    <tr>
        <td>$_SESSION</td>
        <td>переменные сессии, доступные текущему сценарию</td>
    </tr>
    <tr>
        <td>$_REQUEST</td>
        <td>содержимое информации, переданной от браузера; по умолчанию <span class="code">$_get</span>,
            <span class="code">$_post</span> и <span class="code">$_cookie</span></td>
    </tr>
    <tr>
        <td>$_ENV</td>
        <td>переменные, полученные из окружения </td>
    </tr>
</table>

<p>Для иллюстрации порядка применения суперглобальных переменных приведен типовой пример. Среди многой другой интересной информации, предоставляемой суперглобальными переменными, есть и URL-адрес той страницы, с которой пользователь был перенаправлен на текущую веб-страницу. Эта информация может быть получена следующим образом:</p>
<pre><code class="language-php">&lt;?
if(isset($_SERVER['HTTP_REFERER'])) {
    print $_SERVER['HTTP_REFERER'];
}
else
{
    print "nothing";
}
?></code></pre>
<?
if(isset($_SERVER['HTTP_REFERER'])) {
    print $_SERVER['HTTP_REFERER'];
}
else
{
    print "nothing";
}
?>
<p>Обратите внимание, что суперглобальные переменные часто используются злоумышленниками, пытающимися отыскать средства для атаки и вмешательства в работу вашего сайта. Они загружают в $_POST, $_GET или в другие суперглобальные переменные вредоносный код, например команды UNIX или MySQL, которые, если вы по незнанию к ним обратитесь, могут разрушить или отобразить незащищенные данные. Именно поэтому перед применением суперглобальных переменных их всегда следует подвергать предварительной обработке. Для этого можно воспользоваться PHP-функцией htmlentities. Она занимается преобразованием всех символов в элементы HTML. Например, символы «меньше» и «больше» (< и >) превращаются в строки &lt; и &gt;, то же самое делается для перевода в безопасное состояние всех кавычек, обратных слешей и т. д.</p>
<p>Более безопасный способ доступа к $_SERVER (и другим суперглобальным переменным) выглядит следующим образом:</p>
<pre><code class="language-php">$came_from = htmlentities($_SERVER['HTTP_REFERRER']);</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>

<pre><code class="language-php">&lt;?php
switch ($page)
{
    case "Home":
        echo "Вы выбрали Home";
        break;
    case "About":
        echo "Вы выбрали About";
        break;
    case "News":
        echo "Вы выбрали News";
        break;
    case "Login":
        echo "Вы выбрали Login";
        break;
    case "Links":
        echo "Вы выбрали Links";
        break;
}
?>   </code></pre>
<pre><code class="language-php">&lt;?php
function getDeviceType() {
    $userAgent = $_SERVER['HTTP_USER_AGENT'];
    $deviceType = 'Компьютер';  // По умолчанию, если тип не определен

    if (strpos($userAgent, 'Mobile') !== false) {
        $deviceType = 'Мобильное устройство';
    } elseif (strpos($userAgent, 'Tablet') !== false || strpos($userAgent, 'iPad') !== false) {
        $deviceType = 'Планшет';
    }

    return $deviceType;
}

// Использование функции для определения типа устройства
$type = getDeviceType();
echo "Тип вашего устройства: " . $type;
?></code></pre>
<?php
function getDeviceType() {
    $userAgent = $_SERVER['HTTP_USER_AGENT'];
    $deviceType = 'Компьютер';  // По умолчанию, если тип не определен

    if (strpos($userAgent, 'Mobile') !== false) {
        $deviceType = 'Мобильное устройство';
    } elseif (strpos($userAgent, 'Tablet') !== false || strpos($userAgent, 'iPad') !== false) {
        $deviceType = 'Планшет';
    }

    return $deviceType;
}

// Использование функции для определения типа устройства
$type = getDeviceType();
echo "Тип вашего устройства: " . $type . "<br>";
?>
<?
echo $_SERVER['HTTP_USER_AGENT'];
?>

<?
$currentPage = $_SERVER['REQUEST_URI'];
echo $currentPage;
?>

<!--Футер (+скрипты)-->
<?php
include_once $_SERVER['DOCUMENT_ROOT']."/common/footer.php";
?>